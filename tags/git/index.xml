<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Git on Whisper in 39Hz</title>
    <link>https://39hz.github.io/tags/git/</link>
    <description>Recent content in Git on Whisper in 39Hz</description>
    <generator>Hugo -- 0.147.5</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 22 May 2025 12:00:00 +0800</lastBuildDate>
    <atom:link href="https://39hz.github.io/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Git Commands Visualized - Git 命令可视化指南</title>
      <link>https://39hz.github.io/posts/git-commands-visualized/</link>
      <pubDate>Thu, 22 May 2025 12:00:00 +0800</pubDate>
      <guid>https://39hz.github.io/posts/git-commands-visualized/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1&#34;&gt;🔗 原文链接 🌳🚀 CS Visualized: Useful Git Commands&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;尽管 Git 是一个非常强大的工具，但我想大多数人都会同意，它的命令行有时也可能……像一场突如其来的噩梦 😐。别担心！我一直觉得，在脑海中将 Git 操作可视化对于理解其运作机制非常有帮助：当我执行某个命令时，分支是如何交互的？它将如何影响提交历史？为什么当我对 &lt;code&gt;master&lt;/code&gt; 分支执行了 &lt;code&gt;hard reset&lt;/code&gt;、&lt;code&gt;force push&lt;/code&gt; 到 &lt;code&gt;origin&lt;/code&gt; 并且 &lt;code&gt;rimraf&lt;/code&gt; 掉了 &lt;code&gt;.git&lt;/code&gt; 文件夹后，我的同事会崩溃大哭呢？（温馨提示：请勿在共享仓库轻易尝试最后那部分操作！）&lt;/p&gt;
&lt;p&gt;因此，我认为这将是为一些最常用且最实用的 Git 命令创建可视化示例的绝佳机会！🥳 本文将介绍许多命令，它们大多拥有可选参数以改变其行为。在我的示例中，我将着重展示命令的默认行为，尽量不添加（太多）额外的配置选项，力求简洁明了！😄&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;合并-merge&#34;&gt;&lt;a href=&#34;https://www.google.com/search?q=git&amp;#43;merge&#34;&gt;&lt;/a&gt;合并 (Merge)&lt;/h2&gt;
&lt;p&gt;在项目中拥有多个分支，可以将新功能的开发、bug 修复等工作彼此隔离开来，这非常方便。它确保了我们不会意外地将未经批准或可能损坏的代码推送到生产环境。一旦更改得到团队的认可，我们就希望将这些宝贵的成果合并回我们的主生产分支中！&lt;/p&gt;
&lt;p&gt;将更改从一个分支应用到另一个分支的常用方法之一就是执行 &lt;code&gt;git merge&lt;/code&gt;！Git 主要可以执行两种类型的合并：&lt;strong&gt;快进 (fast-forward)&lt;/strong&gt; 🐇 或 &lt;strong&gt;非快进 (no-fast-forward)&lt;/strong&gt; 🐢。&lt;/p&gt;
&lt;p&gt;这听起来可能有点抽象，让我们通过可视化来一探究竟！&lt;/p&gt;
&lt;h3 id=&#34;快进---ff&#34;&gt;&lt;a href=&#34;https://www.google.com/search?q=git&amp;#43;fastforward&#34;&gt;&lt;/a&gt;快进 (&lt;code&gt;--ff&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;当你的目标分支（例如 &lt;code&gt;master&lt;/code&gt;）在你的特性分支（例如 &lt;code&gt;dev&lt;/code&gt;）创建之后，没有产生任何新的提交时，就可以进行&lt;strong&gt;快进合并&lt;/strong&gt;。在这种情况下，Git 有点……&lt;em&gt;小聪明&lt;/em&gt;，它会首先尝试最简单的选项：快进！这种类型的合并不会创建新的提交记录，而是直接将待合并分支（&lt;code&gt;dev&lt;/code&gt;）上的提交“快速移动”到当前分支（&lt;code&gt;master&lt;/code&gt;）的顶端 🥳。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;快进合并&#34; loading=&#34;lazy&#34; src=&#34;https://39hz.github.io/images/git-commands-visualized-merge-ff.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;完美！现在 &lt;code&gt;master&lt;/code&gt; 分支就拥有了 &lt;code&gt;dev&lt;/code&gt; 分支上的所有更改。那么，&lt;strong&gt;非快进合并&lt;/strong&gt;又是什么情况呢？&lt;/p&gt;
&lt;h3 id=&#34;非快进---no-ff&#34;&gt;&lt;a href=&#34;https://www.google.com/search?q=git&amp;#43;nofastfoward&#34;&gt;&lt;/a&gt;非快进 (&lt;code&gt;--no-ff&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;如果你的当前分支与你想要合并的分支相比没有任何额外的提交，那自然是理想状况，但不幸的是，现实中这种情况并不总是发生！如果我们当前所在的分支（比如 &lt;code&gt;master&lt;/code&gt;）上，有一些我们想要合并的分支（比如 &lt;code&gt;dev&lt;/code&gt;）所没有的新提交，Git 就会执行一次&lt;em&gt;非快进合并&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;通过非快进合并，Git 会在你的活动分支（&lt;code&gt;master&lt;/code&gt;）上创建一个新的&lt;em&gt;合并提交&lt;/em&gt;。这个特殊的提交有两个父提交：一个指向当前的活动分支，另一个指向我们想要合并进来的分支！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;非快进合并&#34; loading=&#34;lazy&#34; src=&#34;https://39hz.github.io/images/git-commands-visualized-merge-no-ff.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;干得漂亮，一次完美的合并！🎉 &lt;code&gt;master&lt;/code&gt; 分支现在包含了我们在 &lt;code&gt;dev&lt;/code&gt; 分支上所做的所有更改，并且保留了各自独立开发的历史。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
